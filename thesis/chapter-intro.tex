\chapter{Introduction}
\section{Problem and Motivation}
Traditional network applications are mostly based on the client\,/\,server model, where the server only responds to client requests and the clients do not know each other. 
For some server applications more clients also require more upload bandwidth of the server in order to guarantee quality of service.

In case of real-time video streaming, a server should guarantee, that the ability to play a video fluently does not depend on the number of clients watching the video stream in parallel. In consequence of that, a video streaming server can fundamentally only serve a certain number of clients, which are able to watch the video stream in parallel, so this approach has scalability issues.

To improve this imbalance clients could use their own upload capacity to help the server distributing a given data set. These are called \emph{Peer-to-Peer} networks, where every participant is called a \emph{peer} and is connected to other peers in the network.  If all peers have enough upload bandwidth, it is possible to create a Peer-to-Peer network, which is able to distribute a given data set evenly among all peers within a fixed period of time.

\section{Objective}
This thesis concentrates on implementing a Peer-to-Peer software, which is able to distribute a given data set among any number of peers and never exceeds $2\:T_0$, where $T_0$ is the time needed for a single transfer between two peers measured in seconds. To reach this goal different distribution algorithms have been implemented and evaluated to compare their advantages and disadvantages. The resulting software is able to evaluate these algorithms in terms of efficiency, overhead and performance. The solution is generic and can be used for any kind of data transfers like video streaming or large file transfers.

\section{Structure}
The thesis starts with the evaluation of existing concepts in Chapter \ref{relatedwork} and compares them with the concepts, which are proposed and theoretically discussed in Chapter \ref{theory}. Then the architecture of the software is explained in Chapter \ref{architecture} whereupon the framework and application modules are presented in Chapter \ref{module}. The evaluation of the software follows in Chapter \ref{evaluation}. The last Chapter \ref{conclusion} presents future concepts based on the developed framework.