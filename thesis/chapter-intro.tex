\chapter{Introduction}
\section{Problem and Motivation}
Traditional network applications are mostly based on the client/server model where the server only responds to client requests and the clients do not know each other. 
For some server applications, a higher number of clients also requires an equally higher upload bandwidth of the server in order to guarantee quality of service.

In case of real-time video streaming, a server should guarantee, that the ability to play a video fluently does not depend on the number of clients watching the video stream in parallel. In consequence of that, a video streaming server can fundamentally only serve a certain number of clients, which are able to watch the video stream in parallel, so this approach has scalability issues.

To improve this unbalance the clients could use their own upload capacity to help the server distributing a given data set. Those networks are P2P networks where every participant is called a peer and is connected to other peers in the network. If all peers have enough upload bandwidth, it is possible to create a P2P network, which is able to distribute a given data set evenly among all peers in a fixed time relative to the number of participating peers.

\section{Objective}
This thesis concentrates on implementing a P2P network, which is able to distribute a given data set among any number of clients and never exceeds $2 \cdot T_0$ where $T_0$ is the time needed for a single transfer between the server and a client measured in seconds.

To reach this goal different distribution algorithms are implemented and evaluated to compare advantages and disadvantages. The resulting software is able to measure those algorithms in terms of efficiency, overhead and performance.

The solution is generic and can be used for any kind of data transfers like video streaming or large file transfers.

\section{Structure}
The thesis starts with evaluating existing concepts in chapter \ref{ch:relatedwork} and comparing them with the concepts, which are proposed and theoretically discussed in chapter \ref{ch:theory}. Then the architecture of the software is explained in chapter \ref{ch:arch}. The framework and application modules are presented in chapter \ref{ch:framework} and \ref{ch:app} respectively. The evaluation of the software follows in chapter \ref{ch:eval}. The last chapter \ref{ch:futurework} presents future concepts based on the developed framework.